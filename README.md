#第2章 信息的表示和处理
##1. C语言中移位运算  
左移仅仅在低位补0，右移分为算术位移和逻辑位移两种。算术右移时会在高位补1，如[01100100]算术右移4位为[*1111*0100]；逻辑右移则补0，如[01100100]逻辑右移4位为[*0000*0100]。  
但在Java中，用>>表示算术右移，用>>>表示逻辑右移。  
**注意**：C语言中，对于一个w位的数,如果移动k位(k>=w),在很多机器上则只考虑位移量的低log<sub>2</sub>w位，即k mod w位。但在Java中，已经明确要求按照取模的方式进行移位。
##2. C语言的强制类型转换  
* C语言的强制类型转换并不会改变底层的位模式。例如，考虑如下代码： 

```c
short int v = -12345;
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", v, uv);
```
在一台采用补码的机器上会输出：
```c
v = -12345, uv = 53191
```
这是因为，类型为short的有符号数-12345在机器中用二进制补码表示为[1100 1111 1100 0111]<sub>2</sub>，
在将其转换为无符号数uv时，直接把最高位的符号位当成了数值位来计算，即
2<sup>15</sup>+2<sup>14</sup>+2<sup11</sup>+2<sup>10</sup>+2<sup>9</sup>+
2<sup>8</sup>+2<sup>7</sup>+2<sup>6</sup>+2<sup>2</sup>+2<sup>1</sup>+2<sup>0</sup>=53191。
* 在将范围小的数转换成范围大的数时，先进行位的扩展，再进行转换。如：

```c
short x = -12345;
unsigned y = sx;
printf("y = %u:\t", y);
```

结果输出：

```c
uy = 4294954951:
```
其中，4294954951用16进制表示为0XFFFFCFC7，即先进行位扩展，在高位补1后再进行转换。也即``(unsigned)x``等价于
``(unsigned)(int)x``。
